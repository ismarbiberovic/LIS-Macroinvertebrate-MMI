---
title: "Your LIS MMI Calculator Report"
subtitle: "Automated Assessment of Benthic Community Condition"
author: "Generated by the LIS MMI Calculator Tool"
date: "`r Sys.Date()`"
output: 
  word_document
---

```{r setup, include=FALSE}
# List of required packages
required_packages <- c("dplyr", "ggplot2", "tidyr", "readxl", "openxlsx", 
                       "janitor", "knitr", "tools", "remotes", "stringr", 
                       "BioMonTools", "ggridges", "scales")

# Install missing packages
missing_packages <- required_packages[!(required_packages %in% installed.packages()[,"Package"])]
if(length(missing_packages)) install.packages(missing_packages)

# Load all packages
lapply(required_packages, library, character.only = TRUE)

# Install BioMonTools
if (!requireNamespace("BioMonTools", quietly = TRUE)) {
  remotes::install_github("leppott/BioMonTools", force = TRUE, build_vignettes = FALSE)
}

```

## Project Background

The Connecticut Long Island Sound (CTLIS) Macroinvertebrate Multimetric Index (MMI) is a scientifically robust tool developed to assess the ecological condition of embayment sites in Long Island Sound using benthic macroinvertebrate communities.

*This tool was developed by Tetra Tech in collaboration with CT DEEP and is aligned with the Long Island Sound Study’s Comprehensive Conservation and Management Plan.*

```{r Form & Data, include = FALSE, echo = FALSE}

user_form <- readxl::read_excel(file.path("User Input Data", "Tool Input Form.xlsx"), guess_max = 10^6, skip = 0)
user_form <- user_form %>% janitor::row_to_names(row_number = 3)

file_name       <- as.character(user_form[1,2])
file_type       <- tolower(tools::file_ext(file_name))
cname_sampleid  <- as.character(user_form[2,2])
cname_taxaid    <- as.character(user_form[3,2])
cname_count     <- as.character(user_form[4,2])
ind_thresh      <- as.numeric(user_form[5,2])
taxa_thresh     <- as.numeric(user_form[6,2])

# Extract file name from the form
file_name <- as.character(user_form[1, 2])

# Determine file extension
file_ext <- tolower(file_ext(file_name))

# Read the file based on its extension
if (file_ext == "xlsx") {
  input_data <- readxl::read_excel(file.path("User Input Data", file_name), 
                                   guess_max = 10^6, skip = 0)
} else if (file_ext == "csv") {
  input_data <- readr::read_csv(file.path("User Input Data", file_name), 
                                guess_max = 10^6, skip = 0)
} else {
  stop("Unsupported file type. Please provide a .csv or .xlsx file.")
}

# Source sample macroinvertebrate counts
source_data <- readxl::read_excel(file.path("Tool Files", "Source_LIS_Samples.xlsx"), 
                                  guess_max = 10^6, skip = 0)

# Trait table
trait_data <- readxl::read_excel(file.path("Tool Files", "Traits_4IndexTool.xlsx"),
                                 guess_max = 10^6, skip = 0)


# Create "Output Files" folder if it doesn't already exist
if (!dir.exists("Output Files")) {
  dir.create("Output Files")
}

```

```{r Data Prep, include = FALSE, echo = FALSE}

# Input Data
input_data_df <- 
  input_data

names(input_data_df)[names(input_data_df) == cname_sampleid] <- "SAMPLEID"
names(input_data_df)[names(input_data_df) == cname_taxaid] <- "TAXAID"
names(input_data_df)[names(input_data_df) == cname_count] <- "COUNT"

input_data_df <-
  input_data_df %>%
  dplyr::select(SAMPLEID, TAXAID, COUNT) %>%
  dplyr::mutate(TAXAID = toupper(TAXAID))


# Source Data
metric_cols <- c("pt_CLITELLATA_sc", "pi_STREBLOSPIO_sc", "nt_HeteroMedio_sc", 
                 "pt_IDOTEIDAE_sc", "pi_AMBIest_IandII_sc", "nt_bioturb_gen_sc")

source_data_df <-
  source_data %>%
  dplyr::select(SAMPLEID = UID_v, all_of(metric_cols), MMI6_4928)

```


```{r Source Information, include = FALSE, echo = FALSE}

# Traits 
input_data_df$TAXAID <- trimws(input_data_df$TAXAID)
  
n_taxa            <- length(unique(input_data_df$TAXAID))
n_samps           <- length(unique(input_data_df$SAMPLEID))
n_matchtotraits   <- length(intersect(unique(input_data_df$TAXAID), trait_data$TARGET_TAXON))
n_NOmatchtotraits <- length(setdiff(unique(input_data_df$TAXAID), trait_data$TARGET_TAXON))
nomatch_taxa      <- setdiff(unique(input_data_df$TAXAID), trait_data$TARGET_TAXON)

nomatach_taxa_info <-
  input_data_df %>%
  dplyr::group_by(TAXAID) %>%
  dplyr::count(name = "nOccur_samples") %>%
  dplyr::mutate(`% Occur_samples` = round((nOccur_samples/n_samps)*100, 1)) %>%
  dplyr::filter(TAXAID %in% nomatch_taxa) %>%
  dplyr::mutate(
    Notes = 
      case_when(
        TAXAID %in% trait_data$GENUS ~ "Present in the genus column of the trait table",
        TAXAID %in% trait_data$FAMILY ~ "Present in the family column of the trait table",
        TAXAID %in% trait_data$ORDER ~ "Present in the order column of the trait table",
        TAXAID %in% trait_data$CLASS ~ "Present in the class column of the trait table",
        TAXAID %in% trait_data$PHYLUM ~ "Present in the phylum column of the trait table",
        TRUE ~ NA_character_))

openxlsx::write.xlsx(nomatach_taxa_info, file.path("Output Files", "Taxa Not Matched to Trait Table.xlsx"))

# Samples
nDistinctTaxa_samp <-
  input_data_df %>%
  dplyr::group_by(SAMPLEID) %>%
  dplyr::summarize(
    # Taxa
    `Total # of Distinct Taxa in a Sample` = 
      n_distinct(TAXAID, na.rm = T),
    # Counts
    `Total # of Counted Individuals in a Sample` = 
      sum(COUNT, na.rm = T)) %>%
  
  # Create Flags 
  dplyr::mutate(
    `FLAG: Low % of Individuals in a Sample` = 
      dplyr::if_else(`Total # of Counted Individuals in a Sample` < ind_thresh, 
              paste0("Below your threshold of ", ind_thresh, " individuals"),
              NA),
         
         `FLAG: Low # of Distinct Taxa in a Sample` = 
           dplyr::if_else(`Total # of Distinct Taxa in a Sample` < taxa_thresh, 
              paste0("Below your threshold of ", taxa_thresh, " distinct taxa"),
              NA))

nsamps_FLAG1 <- length(unique(nDistinctTaxa_samp$SAMPLEID[!is.na(nDistinctTaxa_samp$`FLAG: Low % of Individuals in a Sample`)]))
nsamps_FLAG2 <- length(unique(nDistinctTaxa_samp$SAMPLEID[!is.na(nDistinctTaxa_samp$`FLAG: Low # of Distinct Taxa in a Sample`)]))

avg_numDistTaxa <- mean(nDistinctTaxa_samp$`Total # of Distinct Taxa in a Sample`, na.rm = T)
avg_numInd <- mean(nDistinctTaxa_samp$`Total # of Counted Individuals in a Sample`, na.rm = T)

openxlsx::write.xlsx(nDistinctTaxa_samp, file.path("Output Files", "Sample Flags.xlsx"))
```

### Overview of Metrics and MMI Calculation

The Long Island Sound Macroinvertebrate Multimetric Index (MMI) is calculated using six ecological metrics that reflect structural and functional characteristics of benthic macroinvertebrate communities. These metrics are derived from trait-based and taxonomic information and are standardized to a 0–100 scale using scoring formulas based on the 5th and 95th percentiles of calibration data.

The six metrics used in the final MMI model (Model 6_4928) are:

- pt_CLITELLATA: Percent of taxa in the class Clitellata (increases with stress)
- pi_STREBLOSPIO: Percent of individuals in the genus Streblospio (increases with stress)
- nt_HeteroMedio: Number of taxa in the genera Heteromastus and Mediomastus (increases with stress)
- pt_IDOTEIDAE: Percent of taxa in the family Idoteidae (increases with stress)
- pi_AMBIest_IandII: Percent of individuals in AMBI groups I and II (decreases with stress)
- nt_bioturb_gen: Number of taxa classified as bioturbators (decreases with stress)

Each metric is scored using the following formulas:

- pt_CLITELLATA_sc = 100 * (7.1 - value) / (7.1 - 0)
- pi_STREBLOSPIO_sc = 100 * (44.37 - value) / (44.37 - 0)
- nt_HeteroMedio_sc = 100 * (2 - value) / (2 - 0)
- pt_IDOTEIDAE_sc = 100 * (5.99 - value) / (5.99 - 0)
- pi_AMBIest_IandII_sc = 100 * (value - 2.27) / (85.21 - 2.27)
- nt_bioturb_gen_sc = 100 * (value - 7.4) / (33.3 - 7.4)

The index is an average of the sum of the six metrics.

```{r Trait Preparation & User Info, include = FALSE, echo = FALSE}

# Get all Clitellata and Idoteidae taxonomic level names
# Clitellata

clitellata_genera <- c("ALBOGLOSSIPHONIA", "ARCTEONAIS", "AULODRILUS", "BOTHRIONEURUM", 
                       "BRANCHELLION", "BRANCHIURA", "CERNOSVITOVIELLA", "CHAETOGASTER", 
                       "DERO", "DESSEROBDELLA", "DURIDRILUS", "EMBOLOCEPHALUS", "ENCHYTRAEUS", 
                       "ERPOBDELLA", "GLOIOBDELLA", "GLOSSIPHONIA", "GRANIA", "HABER", "HELOBDELLA", 
                       "HIRUDINIDA", "ILYODRILUS", "INANIDRILUS", "ISOCHAETIDES", "LIMNODRILOIDES", 
                       "LIMNODRILUS", "LUMBRICILLUS", "MARVINMEYERIA", "MONOPYLEPHORUS", "NAIS", 
                       "OPHIDONAIS", "PARANAIS", "PIGUETIELLA", "PISCICOLA", "PLACOBDELLA", "PLANORBELLA", 
                       "POTAMOTHRIX", "PRISTINA", "PSAMMORYCTIDES", "QUISTADRILUS", "QUISTRADRILUS", 
                       "RHYACODRILUS", "RIPISTES", "SLAVINA", "SPECARIA", "SPIROSPERMA", "STEPHENSONIANA", 
                       "STYLARIA", "STYLODRILUS", "TASSERKIDRILUS", "TECTIDRILUS", "TENERIDRILUS", 
                       "THALASSODRILIDES", "TRASSERKIDRILUS", "TUBIFEX", "TUBIFICOIDES", "UNCINAIS", 
                       "VARICHAETADRILUS", "VEJDOVSKYELLA")

clitellata_orders <- c("HIRUDINIDA", "TUBIFICIDA", "HAPLOTAXIDA", "CRASSICLITELLATA", 
                       "ENCHYTRAEIDA", "ARHYNCHOBDELLIDA", "RHYNCHOBDELLIDA", 
                       "LUMBRICULIDA", "OLIGOCHAETA")

clitellata_families <- c("GLOSSIPHONIIDAE", "NAIDIDAE", "ENCHYTRAEIDAE", 
                         "ERPOBDELLIDAE", "LUMBRICULIDAE", "PISCICOLIDAE", 
                         "TUBIFICIDAE", "HIRUDINIDAE")


# Idoteidae
idoteidae_genera <- c(
  "AUSTRIDOTEA", "BATEDOTEA", "CLEANTIELLA", "COLIDOTEA",
  "CRABYZOS", "EDOTIA", "ENGIDOTEA", "ERICHSONELLA",
  "EUIDOTEA", "EUSYMMERUS", "GLYPTIDOTEA", "IDOTEA",
  "LYIDOTEA", "MOPLISA", "PARASYMMERUS", "PARIDOTEA",
  "PENTIAS", "PENTIDOTEA", "PLATIDOTEA", "SYNIDOTEA",
  "SYNISCHIA", "SYNISOMA"
)

# Join taxonomic information and traits to the input file
input_data_df_v1 <- 
  input_data_df %>%
  dplyr::left_join(., trait_data, by = c("TAXAID" = "TARGET_TAXON"))

# Create columns in the input file
input_data_df_v2 <- 
  input_data_df_v1 %>%
  dplyr::mutate(
    # Clitellata
    isClitellata = case_when(
                    stringr::str_detect(TAXAID, stringr::str_c(clitellata_genera, collapse = "|")) ~ "Yes",
                     TAXAID %in% clitellata_genera ~ "Yes",
                     TAXAID %in% clitellata_orders ~ "Yes",
                     TAXAID %in% clitellata_families ~ "Yes",
                     GENUS %in% clitellata_genera ~ "Yes",
                     ORDER %in% clitellata_orders ~ "Yes",
                     FAMILY %in% clitellata_families ~ "Yes",
                     CLASS == "CLITELLATA" ~ "Yes",
                     TRUE ~ "No"
                     ),
    
    # Idoteidae
    isIdoteidae = case_when(
                    stringr::str_detect(TAXAID, stringr::str_c(idoteidae_genera, collapse = "|")) ~ "Yes",
                     TAXAID %in% idoteidae_genera ~ "Yes",
                     FAMILY == "IDOTEIDAE" ~ "Yes",
                     TRUE ~ "No"
                     ),
    
    # Streblospio
    isStreblospio = case_when(
                      stringr::str_detect(TAXAID, "STREBLOSPIO") ~ "Yes",
                       TAXAID %in% "STREBLOSPIO" ~ "Yes",
                       GENUS == "STREBLOSPIO" ~ "Yes",
                       TRUE ~ "No"
                       ),
    
    # Heteromastus and Mediomastus
    isHeteroMedio = case_when(
                      stringr::str_detect(TAXAID, "HETEROMASTUS|MEDIOMASTUS") ~ "Yes",
                       TAXAID %in% c("HETEROMASTUS", "MEDIOMASTUS") ~ "Yes",
                       GENUS %in% c("HETEROMASTUS", "MEDIOMASTUS") ~ "Yes",
                       TRUE ~ "No"
                       ),
    
    # AMBI I or II
    isAMBI_IorII = case_when(
                          AMBI_Final %in% c("I", "II") ~ "Yes",
                          TRUE ~ "No",
                           ),
    
    # Bioturbator
    isBioturbator = case_when(
                       Bioturbation_Final == "Bioturbator" ~ "Yes",
                       TRUE ~ "No"
                       )
    )
  
# Additional User Information
n_clitellata   <- length(unique(input_data_df_v2$TAXAID[input_data_df_v2$isClitellata == "Yes"]))
n_idoteidae    <- length(unique(input_data_df_v2$TAXAID[input_data_df_v2$isIdoteidae == "Yes"]))
n_streblospio  <- length(unique(input_data_df_v2$TAXAID[input_data_df_v2$isStreblospio == "Yes"]))
n_heteromedio  <- length(unique(input_data_df_v2$TAXAID[input_data_df_v2$isHeteroMedio == "Yes"]))
n_ambi         <- length(unique(input_data_df_v2$TAXAID[input_data_df_v2$isAMBI_IorII == "Yes"]))
n_bioturb      <- length(unique(input_data_df_v2$TAXAID[input_data_df_v2$isBioturbator == "Yes"]))

```


### Summary of Your Input Data

Thank you for using the LIS MMI Calculator. Based on the data you provided:

- A total of `r n_taxa` unique taxa were identified across `r n_samps` samples.
- Of these, `r n_matchtotraits` taxa were successfully matched to the trait table, enabling trait-based metric calculations. However, please note that a match does not guarantee complete trait information for all metrics. Refer to the list below for details on trait coverage and completeness.

> *Note: You are welcome to explore the trait table in the Tool Files folder and enhance it with additional information if you have access to relevant sources. Expanding trait coverage can improve the accuracy and completeness of metric calculations.*

- `r n_NOmatchtotraits` taxa could not be matched to any trait information. A detailed list of these unmatched taxa has been saved to the file Taxa Not Matched to Trait Table.xlsx in the `Output Files` folder.

In addition, `r nsamps_FLAG1` sample(s) were flagged for having a low number of individuals and
`r nsamps_FLAG2` sample(s) were flagged for having a low number of distinct taxa (based on your numbers in the input form). 
These flags are summarized in the file Sample Flags.xlsx, also located in the `Output Files` folder. On average, 
each sample contained approximately `r round(avg_numDistTaxa, 1)` distinct taxa and `r round(avg_numInd, 1)` total individuals.

These checks help ensure that your data are suitable for calculating the CTLIS MMI. If you have questions about unmatched taxa or flagged samples, please refer to the output files or contact the project team for support.

Out of these `r n_taxa` unique taxa identified in your samples:

- `r n_clitellata` belong to the class Clitellata,
- `r n_idoteidae` are members of the family Idoteidae,
- `r n_streblospio` are from the genus Streblospio,
- `r n_heteromedio` belong to either the Heteromastus or Mediomastus genera,
- `r n_ambi` are considered sensitive taxa (i.e., those with AMBI scores of I or II),
- and `r n_bioturb` are classified as bioturbators.

> *Note: It is common for genera such as* Streblospio, Heteromastus, *and* Mediomastus *to be represented by only one or a few species in benthic datasets. Despite their low taxonomic diversity, these genera are often ecologically significant and frequently encountered in estuarine and coastal environments.*

```{r Metric Calculation & Scoring, echo=F, include=F}

# Excluding non-target taxa
TaxaLevels <- c(  "Phylum", "Class", "Order", "Family", "Genus", "Species")
# Exclude taxa are refered to by multiple names; ambiguous, non-distinct, and non-unique. 
# The "exclude" name was chosen so as to be consistent with "non-target" taxa. 
# That is, taxa marked as "TRUE" are treated as undesireables. 
# Exclude taxa are those that are present in a sample when taxa of the same 
# group are present in the same sample are identified finer level. 
# That is, the parent is marked as exclude when child taxa are present in 
# the same sample.
input_data_excl <-
  BioMonTools::markExcluded(input_data_df_v2,
                            SampID = "SAMPLEID",
                            TaxaID = "TAXAID",
                            TaxaCount = "COUNT",
                            Exclude = "EXCLUDE",
                            TaxaLevels,
                            Exceptions = NA)

# Calculate Metrics 
input_data_metrics <-
  input_data_excl %>%
  ungroup() %>%
  group_by(SAMPLEID) %>%
  summarize(ni_total = sum(COUNT),
            nt_total = dplyr::n_distinct(TAXAID[EXCLUDE != TRUE], na.rm = T),
            
            # Clitellata 
            NT_CLITELLATA = dplyr::n_distinct(TAXAID[EXCLUDE != TRUE & isClitellata == "Yes"], na.rm = T),
            PT_CLITELLATA = round(100* NT_CLITELLATA / nt_total, 1),
            
            # Streblospio
            NI_STREBLOSPIO = sum(COUNT[isStreblospio == "Yes"], na.rm = T),
            PI_STREBLOSPIO = round(100 * NI_STREBLOSPIO / ni_total, 1),
            
            # Heteromastus and Mediomastus
            NT_HETEROMEDIO = dplyr::n_distinct(TAXAID[EXCLUDE != TRUE & isHeteroMedio == "Yes"], na.rm = T),
            
            # Idoteidae 
            NT_IDOTEIDAE = dplyr::n_distinct(TAXAID[EXCLUDE != TRUE & isIdoteidae == "Yes"], na.rm = T),
            PT_IDOTEIDAE = round(100* NT_IDOTEIDAE / nt_total, 1),
            
            # AMBI
            NI_AMBIest_IandII = sum(COUNT[isAMBI_IorII == "Yes"], na.rm = T),
            PI_AMBIest_IandII = round(100 * NI_AMBIest_IandII / ni_total, 1),
            
            # Bioturbators
            NT_BIOTURBATORS = dplyr::n_distinct(TAXAID[EXCLUDE != TRUE & isBioturbator == "Yes"], na.rm = T)
            
            ) %>%
  
  select(-NT_CLITELLATA, -NI_STREBLOSPIO, -NT_IDOTEIDAE, -NI_AMBIest_IandII)

# Score Metrics 
input_data_scMetrics <-
  input_data_metrics %>%
  
  # Score Metrics
  dplyr::mutate(
    PT_CLITELLATA_SC = 100 * (7.1 - PT_CLITELLATA) / (7.1 - 0),
    PI_STREBLOSPIO_SC = 100 * (44.37 - PI_STREBLOSPIO) / (44.37 - 0),
    NT_HETEROMEDIO_SC = 100 * (2 - NT_HETEROMEDIO) / (2 - 0),
    PT_IDOTEIDAE_SC = 100 * (5.99 - PT_IDOTEIDAE) / (5.99 - 0),
    PI_AMBIEST_IANDII_SC = 100 * (PI_AMBIest_IandII - 3.91) / (83.5 - 3.91),
    NT_BIOTURBATORS_SC = 100 * (NT_BIOTURBATORS - 7.4) / (33.3 - 7.4)
  ) %>%
  
  # Cap Metrics to 0 - 100
  dplyr::mutate(
    PT_CLITELLATA_SC_cap = scales::squish(PT_CLITELLATA_SC, range = c(0, 100)),
    PI_STREBLOSPIO_SC_cap = scales::squish(PI_STREBLOSPIO_SC, range = c(0, 100)),
    NT_HETEROMEDIO_SC_cap = scales::squish(NT_HETEROMEDIO_SC, range = c(0, 100)),
    PT_IDOTEIDAE_SC_cap = scales::squish(PT_IDOTEIDAE_SC, range = c(0, 100)),
    PI_AMBIEST_IANDII_SC_cap = scales::squish(PI_AMBIEST_IANDII_SC, range = c(0, 100)),
    NT_BIOTURBATORS_SC_cap = scales::squish(NT_BIOTURBATORS_SC, range = c(0, 100))
  ) %>%
  
  
    dplyr::mutate(dplyr::across(dplyr::ends_with("_cap"), ~round(., 1)),
                  dplyr::across(dplyr::ends_with("_SC"), ~round(., 1)))
```

# Metric and Index information of Your Samples

```{r ScaledMetricSummaryFormatted, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}
# Calculate summary statistics
summary_stats <- input_data_scMetrics %>%
  summarise(across(ends_with("_SC_cap"), 
                   list(mean = mean, sd = sd, min = min, max = max), 
                   .names = "{.col}_{.fn}", na.rm = TRUE))

# Reshape to long format
summary_stats_long <- summary_stats %>%
  tidyr::pivot_longer(cols = everything(),
                      names_to = c("Metric", "Statistic"),
                      names_sep = "_SC_cap_") %>%
  tidyr::pivot_wider(names_from = Statistic, values_from = value)

# Clean metric names
summary_stats_long$Metric <- gsub("_SC_cap", "", summary_stats_long$Metric)

# Display table
knitr::kable(summary_stats_long, 
      caption = "Table: Summary statistics (mean, standard deviation, min, max) for each scaled metric used in the MMI calculation.",
      digits = 1,
      format = "markdown")
```



```{r MMI & Plot, echo=F, include=F}

# Index Calculation
input_data_MMI <-
  input_data_scMetrics %>%
  dplyr::mutate(MMI = (PT_CLITELLATA_SC_cap + PI_STREBLOSPIO_SC_cap + NT_HETEROMEDIO_SC_cap +
                PT_IDOTEIDAE_SC_cap + PI_AMBIEST_IANDII_SC_cap + NT_BIOTURBATORS_SC_cap) / 6) %>%
  dplyr::mutate(MMI = scales::squish(MMI, range = c(0,100)),
                MMI = round(MMI, 1))

input_data_4user <- 
  input_data_MMI %>%
  select(SAMPLEID, ni_total, nt_total, PT_CLITELLATA:NT_BIOTURBATORS, ends_with("_cap"), MMI) %>%
  rename_with(~ gsub("_SC_cap", "_scored", .x), .cols = ends_with("_SC_cap"))

write.xlsx(input_data_4user, file.path("Output Files", "Your Metrics and Index.xlsx"))

# Geom Ridges
input_data_long <- 
  input_data_MMI %>%
  select(SAMPLEID, MMI) %>%
  mutate(Source = "Your Input Data")

lis_data <- 
  source_data %>%
  select(SAMPLEID = UID_v, MMI = MMI6_4928) %>%
  mutate(Source = "LIS Source Data")

ridge_data <- bind_rows(input_data_long, lis_data) %>% mutate(Source2 = "Yes")


ggplot2::ggplot(ridge_data, aes(x = MMI, y = Source)) +
  ggridges::geom_density_ridges(
    jittered_points = TRUE,  
    position = position_raincloud(adjust_vlines = TRUE),
    quantile_lines = TRUE,
    vline_size = 1, 
    vline_color = "red4",
    alpha = 0.7, 
    scale = 1, 
    fill = "orange2",
    point_size = 1, 
    point_alpha = 0.7,
  ) +
  ggplot2::theme_classic() +
  ggplot2::scale_x_continuous(
    expand = expansion(mult = c(0.1, 0.1)),
    breaks = c(0, 20, 40, 60, 80, 100)) +
  ggplot2::theme(
    axis.title.y = element_blank(),
    axis.title.x = element_text(size = 16),
    axis.text.x = element_text(size = 12),
    axis.line.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.text.y = element_text(size = 14, face = "bold", hjust = 1, vjust = -0.05),
    axis.line.x = element_line(size = 1),
    axis.ticks.x = element_line(size = 1)
  )

ggsave(filename = file.path("Output Files", "Plot_of_your_data.jpeg"), dpi = 600,
       width = 8, height = 6)

```

```{r MMI Summary, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}
# Calculate summary statistics
summary_stats_mmi <- 
  input_data_MMI %>%
  summarise(
    min = min(MMI, na.rm = T),
    p25 = quantile(MMI, 0.25, na.rm = T),
    mean = mean(MMI, na.rm = T),
    median = median(MMI, na.rm =T),
    sd = sd(MMI, na.rm = T),
    p75 = quantile(MMI, 0.75, na.rm = T),
    max = max(MMI, na.rm = T)
  )


# Extract each as a named vector
mmi_min    <- round(summary_stats_mmi$min, 1)
mmi_p25    <- round(summary_stats_mmi$p25, 1)
mmi_mean   <- round(summary_stats_mmi$mean, 1)
mmi_median <- round(summary_stats_mmi$median, 1)
mmi_sd     <- round(summary_stats_mmi$sd, 1)
mmi_p75    <- round(summary_stats_mmi$p75, 1)
mmi_max    <- round(summary_stats_mmi$max, 1)

```

# Interpreting Your Results
The LIS multimetric index scores in your data range from `r mmi_min` to `r mmi_max`, 
with a mean of `r mmi_mean` and a standard deviation of `r mmi_sd`. The median
index score of your data is `r mmi_median`, with 25% of values below `r mmi_p25` and
25% of values above `r mmi_p75`. 

High MMI values typically indicate good ecological condition, while low MMI values suggest degraded ecological condition. To better understand how your MMI scores compare to those used in the development of the index, refer to Plot_of_your_data.jpeg. This plot illustrates the distribution of scores across different data sources, with red vertical lines marking key quantiles such as the first quartile (Q1), median, and third quartile (Q3). Individual samples are shown as jittered points, which help visualize the spread and density of the data.

If you have any questions or need assistance, feel free to reach out using the contact information in the user guide.